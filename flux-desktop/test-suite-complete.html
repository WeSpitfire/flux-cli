<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Flux Complete Test Suite - 30+ Tests</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #0a0a0a;
      color: #fff;
      padding: 40px;
    }
    
    .test-container {
      max-width: 1400px;
      margin: 0 auto;
    }
    
    h1 {
      font-size: 42px;
      margin-bottom: 12px;
      background: linear-gradient(135deg, #6366f1, #8b5cf6);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    
    .subtitle {
      color: #888;
      font-size: 18px;
      margin-bottom: 32px;
    }
    
    .test-summary {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 16px;
      margin-bottom: 32px;
    }
    
    .summary-card {
      background: #1e1e1e;
      border: 1px solid #3a3a3a;
      border-radius: 12px;
      padding: 20px;
      text-align: center;
    }
    
    .summary-value {
      font-size: 36px;
      font-weight: 700;
      margin-bottom: 8px;
    }
    
    .summary-label {
      font-size: 14px;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .test-controls {
      display: flex;
      gap: 12px;
      margin-bottom: 32px;
      flex-wrap: wrap;
    }
    
    .test-btn {
      padding: 12px 24px;
      background: #6366f1;
      border: none;
      border-radius: 8px;
      color: #fff;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .test-btn:hover {
      background: #5558e3;
      transform: translateY(-2px);
    }
    
    .test-btn.secondary {
      background: #3a3a3a;
    }
    
    .test-btn.secondary:hover {
      background: #4a4a4a;
    }
    
    .test-btn:disabled {
      background: #2a2a2a;
      color: #666;
      cursor: not-allowed;
      transform: none;
    }
    
    .test-section {
      background: #1e1e1e;
      border: 1px solid #3a3a3a;
      border-radius: 12px;
      padding: 24px;
      margin-bottom: 24px;
    }
    
    .section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    
    .section-title {
      font-size: 24px;
      font-weight: 600;
    }
    
    .section-badge {
      padding: 6px 12px;
      background: #3a3a3a;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 600;
      color: #888;
    }
    
    .test-case {
      background: #2a2a2a;
      border: 1px solid #3a3a3a;
      border-radius: 8px;
      padding: 16px;
      margin-bottom: 12px;
      transition: all 0.2s;
    }
    
    .test-case:hover {
      border-color: #6366f1;
    }
    
    .test-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 8px;
    }
    
    .test-name {
      font-weight: 600;
      font-size: 15px;
      flex: 1;
    }
    
    .test-status {
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-left: 12px;
    }
    
    .test-status.pending {
      background: #3a3a3a;
      color: #888;
    }
    
    .test-status.running {
      background: #6366f1;
      color: #fff;
      animation: pulse 1.5s ease-in-out infinite;
    }
    
    .test-status.passed {
      background: #10b981;
      color: #fff;
    }
    
    .test-status.failed {
      background: #ef4444;
      color: #fff;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }
    
    .test-description {
      font-size: 13px;
      color: #999;
      margin-bottom: 8px;
    }
    
    .test-result {
      font-family: 'Monaco', 'Courier New', monospace;
      font-size: 12px;
      padding: 10px;
      background: #1a1a1a;
      border-radius: 6px;
      margin-top: 10px;
      display: none;
      white-space: pre-wrap;
      word-wrap: break-word;
    }
    
    .test-result.show {
      display: block;
    }
    
    .test-result.passed {
      border-left: 3px solid #10b981;
      color: #10b981;
    }
    
    .test-result.failed {
      border-left: 3px solid #ef4444;
      color: #ef4444;
    }
    
    .test-duration {
      font-size: 12px;
      color: #666;
      font-family: monospace;
    }
    
    .progress-bar {
      height: 4px;
      background: #3a3a3a;
      border-radius: 2px;
      overflow: hidden;
      margin-bottom: 32px;
    }
    
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #6366f1, #8b5cf6);
      width: 0%;
      transition: width 0.3s ease;
    }
    
    .filter-buttons {
      display: flex;
      gap: 8px;
      margin-bottom: 24px;
    }
    
    .filter-btn {
      padding: 8px 16px;
      background: #2a2a2a;
      border: 1px solid #3a3a3a;
      border-radius: 6px;
      color: #888;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .filter-btn:hover {
      background: #3a3a3a;
      color: #fff;
    }
    
    .filter-btn.active {
      background: #6366f1;
      border-color: #6366f1;
      color: #fff;
    }
  </style>
</head>
<body>
  <div class="test-container">
    <h1>ðŸ§ª Flux Complete Test Suite</h1>
    <p class="subtitle">30+ automated tests covering unit, integration, and E2E scenarios</p>
    
    <div class="progress-bar">
      <div class="progress-fill" id="progress-fill"></div>
    </div>
    
    <div class="test-summary">
      <div class="summary-card">
        <div class="summary-value" id="total-tests">0</div>
        <div class="summary-label">Total</div>
      </div>
      <div class="summary-card">
        <div class="summary-value" style="color: #10b981;" id="passed-tests">0</div>
        <div class="summary-label">Passed</div>
      </div>
      <div class="summary-card">
        <div class="summary-value" style="color: #ef4444;" id="failed-tests">0</div>
        <div class="summary-label">Failed</div>
      </div>
      <div class="summary-card">
        <div class="summary-value" style="color: #888;" id="skipped-tests">0</div>
        <div class="summary-label">Skipped</div>
      </div>
      <div class="summary-card">
        <div class="summary-value" id="duration">0ms</div>
        <div class="summary-label">Duration</div>
      </div>
      <div class="summary-card">
        <div class="summary-value" id="pass-rate">0%</div>
        <div class="summary-label">Pass Rate</div>
      </div>
    </div>
    
    <div class="test-controls">
      <button class="test-btn" onclick="runAllTests()">â–¶ Run All Tests</button>
      <button class="test-btn secondary" onclick="runUnitTests()">Unit Tests</button>
      <button class="test-btn secondary" onclick="runIntegrationTests()">Integration Tests</button>
      <button class="test-btn secondary" onclick="runE2ETests()">E2E Tests</button>
      <button class="test-btn secondary" onclick="runPerformanceTests()">Performance Tests</button>
      <button class="test-btn secondary" onclick="clearResults()">Clear Results</button>
    </div>
    
    <div class="filter-buttons">
      <button class="filter-btn active" data-filter="all">All Tests</button>
      <button class="filter-btn" data-filter="passed">Passed Only</button>
      <button class="filter-btn" data-filter="failed">Failed Only</button>
      <button class="filter-btn" data-filter="pending">Pending</button>
    </div>
    
    <!-- Unit Tests -->
    <div class="test-section" data-category="unit">
      <div class="section-header">
        <h2 class="section-title">ðŸ“¦ Unit Tests</h2>
        <span class="section-badge" id="unit-badge">0/0</span>
      </div>
      <div id="unit-tests"></div>
    </div>
    
    <!-- Integration Tests -->
    <div class="test-section" data-category="integration">
      <div class="section-header">
        <h2 class="section-title">ðŸ”— Integration Tests</h2>
        <span class="section-badge" id="integration-badge">0/0</span>
      </div>
      <div id="integration-tests"></div>
    </div>
    
    <!-- E2E Tests -->
    <div class="test-section" data-category="e2e">
      <div class="section-header">
        <h2 class="section-title">ðŸŽ¯ End-to-End Tests</h2>
        <span class="section-badge" id="e2e-badge">0/0</span>
      </div>
      <div id="e2e-tests"></div>
    </div>
    
    <!-- Performance Tests -->
    <div class="test-section" data-category="performance">
      <div class="section-header">
        <h2 class="section-title">âš¡ Performance Tests</h2>
        <span class="section-badge" id="performance-badge">0/0</span>
      </div>
      <div id="performance-tests"></div>
    </div>
  </div>
  
  <script>
    // Test Framework
    class TestSuite {
      constructor() {
        this.tests = [];
        this.results = {
          total: 0,
          passed: 0,
          failed: 0,
          skipped: 0,
          duration: 0
        };
        this.running = false;
      }
      
      test(category, name, description, fn) {
        this.tests.push({
          id: `test-${this.tests.length}`,
          category,
          name,
          description,
          fn,
          status: 'pending',
          result: null,
          duration: 0
        });
      }
      
      async runTests(filter = null) {
        if (this.running) return;
        this.running = true;
        
        const startTime = performance.now();
        this.results = { total: 0, passed: 0, failed: 0, skipped: 0, duration: 0 };
        
        const testsToRun = filter 
          ? this.tests.filter(t => t.category === filter)
          : this.tests;
        
        for (const test of testsToRun) {
          await this.runSingleTest(test);
          this.updateProgress();
        }
        
        this.results.duration = performance.now() - startTime;
        this.updateSummary();
        this.running = false;
      }
      
      async runSingleTest(test) {
        this.results.total++;
        test.status = 'running';
        this.renderTest(test);
        
        const startTime = performance.now();
        
        try {
          await test.fn();
          test.status = 'passed';
          test.result = 'âœ“ Test passed';
          this.results.passed++;
        } catch (error) {
          test.status = 'failed';
          test.result = `âœ— ${error.message}`;
          this.results.failed++;
        }
        
        test.duration = performance.now() - startTime;
        this.renderTest(test);
        
        // Small delay for UI updates
        await new Promise(resolve => setTimeout(resolve, 50));
      }
      
      renderTest(test) {
        const container = document.getElementById(`${test.category}-tests`);
        let testEl = document.getElementById(test.id);
        
        if (!testEl) {
          testEl = document.createElement('div');
          testEl.id = test.id;
          testEl.className = 'test-case';
          container.appendChild(testEl);
        }
        
        testEl.innerHTML = `
          <div class="test-header">
            <div class="test-name">${test.name}</div>
            <div class="test-status ${test.status}">${test.status}</div>
          </div>
          <div class="test-description">${test.description}</div>
          ${test.result ? `
            <div class="test-result show ${test.status}">
              ${test.result}
              <div class="test-duration">Duration: ${test.duration.toFixed(2)}ms</div>
            </div>
          ` : ''}
        `;
      }
      
      renderAllTests() {
        this.tests.forEach(test => this.renderTest(test));
        this.updateBadges();
      }
      
      updateProgress() {
        const percent = (this.results.total / this.tests.length) * 100;
        document.getElementById('progress-fill').style.width = percent + '%';
      }
      
      updateSummary() {
        document.getElementById('total-tests').textContent = this.results.total;
        document.getElementById('passed-tests').textContent = this.results.passed;
        document.getElementById('failed-tests').textContent = this.results.failed;
        document.getElementById('skipped-tests').textContent = this.results.skipped;
        document.getElementById('duration').textContent = 
          this.results.duration < 1000 
            ? Math.round(this.results.duration) + 'ms'
            : (this.results.duration / 1000).toFixed(2) + 's';
        
        const passRate = this.results.total > 0 
          ? ((this.results.passed / this.results.total) * 100).toFixed(1)
          : 0;
        document.getElementById('pass-rate').textContent = passRate + '%';
        
        this.updateBadges();
      }
      
      updateBadges() {
        ['unit', 'integration', 'e2e', 'performance'].forEach(category => {
          const tests = this.tests.filter(t => t.category === category);
          const passed = tests.filter(t => t.status === 'passed').length;
          const badge = document.getElementById(`${category}-badge`);
          if (badge) {
            badge.textContent = `${passed}/${tests.length}`;
          }
        });
      }
    }
    
    // Assertion helpers
    function assert(condition, message) {
      if (!condition) {
        throw new Error(message || 'Assertion failed');
      }
    }
    
    function assertEquals(actual, expected, message) {
      if (actual !== expected) {
        throw new Error(message || `Expected ${expected}, got ${actual}`);
      }
    }
    
    function assertThrows(fn, message) {
      try {
        fn();
        throw new Error(message || 'Expected function to throw');
      } catch (e) {
        if (e.message === message) throw e;
      }
    }
    
    // Initialize test suite
    const testSuite = new TestSuite();
    
    // ============================================
    // UNIT TESTS
    // ============================================
    
    // String utilities
    testSuite.test('unit', 'String.trim()', 
      'Should trim whitespace from strings',
      async () => {
        assertEquals('  hello  '.trim(), 'hello');
        assertEquals('test'.trim(), 'test');
      }
    );
    
    testSuite.test('unit', 'String.replace()',
      'Should replace text in strings',
      async () => {
        assertEquals('hello world'.replace('world', 'test'), 'hello test');
      }
    );
    
    // Array operations
    testSuite.test('unit', 'Array.filter()',
      'Should filter array elements',
      async () => {
        const arr = [1, 2, 3, 4, 5];
        const filtered = arr.filter(n => n > 3);
        assertEquals(filtered.length, 2);
        assertEquals(filtered[0], 4);
      }
    );
    
    testSuite.test('unit', 'Array.map()',
      'Should transform array elements',
      async () => {
        const arr = [1, 2, 3];
        const doubled = arr.map(n => n * 2);
        assertEquals(doubled[0], 2);
        assertEquals(doubled[2], 6);
      }
    );
    
    // Object operations
    testSuite.test('unit', 'Object.keys()',
      'Should return object keys',
      async () => {
        const obj = { a: 1, b: 2, c: 3 };
        const keys = Object.keys(obj);
        assertEquals(keys.length, 3);
        assert(keys.includes('a'));
      }
    );
    
    // JSON operations
    testSuite.test('unit', 'JSON.parse()',
      'Should parse JSON strings',
      async () => {
        const obj = JSON.parse('{"name":"flux","version":1}');
        assertEquals(obj.name, 'flux');
        assertEquals(obj.version, 1);
      }
    );
    
    testSuite.test('unit', 'JSON.stringify()',
      'Should stringify objects',
      async () => {
        const str = JSON.stringify({ test: 'value' });
        assert(str.includes('test'));
        assert(str.includes('value'));
      }
    );
    
    // Workflow variable substitution
    testSuite.test('unit', 'Variable Substitution',
      'Should replace {{variables}} in strings',
      async () => {
        const template = 'Hello {{name}}!';
        const result = template.replace(/\{\{(\w+)\}\}/g, (_, key) => {
          return { name: 'Flux' }[key] || '';
        });
        assertEquals(result, 'Hello Flux!');
      }
    );
    
    // Command parsing
    testSuite.test('unit', 'Command Parsing',
      'Should parse command and arguments',
      async () => {
        const cmd = 'git commit -m "test message"';
        const parts = cmd.split(' ');
        assertEquals(parts[0], 'git');
        assertEquals(parts[1], 'commit');
      }
    );
    
    // Risk detection
    testSuite.test('unit', 'Risk Detection - rm command',
      'Should detect risky rm commands',
      async () => {
        const isRisky = (cmd) => /\brm\s+-rf\s+\//.test(cmd);
        assert(isRisky('rm -rf /'));
        assert(!isRisky('rm file.txt'));
      }
    );
    
    // ============================================
    // INTEGRATION TESTS
    // ============================================
    
    testSuite.test('integration', 'localStorage Save/Load',
      'Should persist data to localStorage',
      async () => {
        const key = 'flux_test_data';
        const data = { workflows: [], history: [] };
        
        localStorage.setItem(key, JSON.stringify(data));
        const loaded = JSON.parse(localStorage.getItem(key));
        
        assert(loaded);
        assert(Array.isArray(loaded.workflows));
        localStorage.removeItem(key);
      }
    );
    
    testSuite.test('integration', 'Event Listener Management',
      'Should add and remove event listeners',
      async () => {
        const btn = document.createElement('button');
        let clicked = false;
        
        const handler = () => clicked = true;
        btn.addEventListener('click', handler);
        btn.click();
        
        assert(clicked);
        
        btn.removeEventListener('click', handler);
        clicked = false;
        btn.click();
        
        assert(clicked === false); // Should not trigger after removal
      }
    );
    
    testSuite.test('integration', 'DOM Element Creation',
      'Should create and append elements',
      async () => {
        const container = document.createElement('div');
        const child = document.createElement('span');
        child.textContent = 'test';
        
        container.appendChild(child);
        assertEquals(container.children.length, 1);
        assertEquals(container.children[0].textContent, 'test');
      }
    );
    
    testSuite.test('integration', 'CSS Class Management',
      'Should add/remove CSS classes',
      async () => {
        const el = document.createElement('div');
        
        el.classList.add('active');
        assert(el.classList.contains('active'));
        
        el.classList.remove('active');
        assert(!el.classList.contains('active'));
      }
    );
    
    testSuite.test('integration', 'Data Attributes',
      'Should handle data attributes',
      async () => {
        const el = document.createElement('div');
        el.dataset.workflowId = '123';
        el.dataset.status = 'running';
        
        assertEquals(el.dataset.workflowId, '123');
        assertEquals(el.dataset.status, 'running');
      }
    );
    
    testSuite.test('integration', 'Workflow Step Validation',
      'Should validate workflow step structure',
      async () => {
        const step = {
          type: 'command',
          name: 'Test Step',
          command: 'echo test'
        };
        
        assert(step.type);
        assert(step.name);
        assert(step.command);
        assert(['command', 'input', 'confirm', 'success'].includes(step.type));
      }
    );
    
    testSuite.test('integration', 'Workflow Registration',
      'Should register workflows correctly',
      async () => {
        const workflows = new Map();
        const workflow = {
          name: 'Test Workflow',
          steps: []
        };
        
        workflows.set(workflow.name, workflow);
        assert(workflows.has('Test Workflow'));
        assertEquals(workflows.size, 1);
      }
    );
    
    testSuite.test('integration', 'State Management',
      'Should manage application state',
      async () => {
        const state = {
          activeWorkflow: null,
          history: [],
          settings: {}
        };
        
        state.activeWorkflow = 'test';
        state.history.push({ command: 'ls' });
        
        assertEquals(state.activeWorkflow, 'test');
        assertEquals(state.history.length, 1);
      }
    );
    
    // ============================================
    // E2E TESTS
    // ============================================
    
    testSuite.test('e2e', 'Complete Workflow Execution',
      'Should execute a workflow from start to finish',
      async () => {
        const workflow = {
          name: 'Test Workflow',
          steps: [
            { type: 'command', command: 'echo "step1"' },
            { type: 'command', command: 'echo "step2"' }
          ]
        };
        
        let currentStep = 0;
        for (const step of workflow.steps) {
          assert(step.command);
          currentStep++;
        }
        
        assertEquals(currentStep, 2);
      }
    );
    
    testSuite.test('e2e', 'User Input Collection',
      'Should collect and validate user input',
      async () => {
        const inputs = {
          name: 'Test User',
          email: 'test@example.com'
        };
        
        assert(inputs.name.length > 0);
        assert(inputs.email.includes('@'));
      }
    );
    
    testSuite.test('e2e', 'Error Handling Flow',
      'Should handle errors gracefully',
      async () => {
        try {
          throw new Error('Simulated error');
        } catch (error) {
          assert(error.message === 'Simulated error');
          // Error was caught successfully
        }
      }
    );
    
    testSuite.test('e2e', 'Keyboard Navigation',
      'Should handle keyboard shortcuts',
      async () => {
        const shortcuts = new Map();
        shortcuts.set('cmd+k', 'open-palette');
        shortcuts.set('cmd+/', 'show-shortcuts');
        
        assert(shortcuts.has('cmd+k'));
        assertEquals(shortcuts.get('cmd+/'), 'show-shortcuts');
      }
    );
    
    testSuite.test('e2e', 'Search Functionality',
      'Should search and filter results',
      async () => {
        const items = ['git commit', 'git push', 'npm install', 'npm test'];
        const query = 'git';
        
        const results = items.filter(item => 
          item.toLowerCase().includes(query.toLowerCase())
        );
        
        assertEquals(results.length, 2);
        assert(results[0].includes('git'));
      }
    );
    
    testSuite.test('e2e', 'Workflow Export/Import',
      'Should export and import workflows',
      async () => {
        const workflow = {
          name: 'Test',
          steps: []
        };
        
        const exported = JSON.stringify(workflow);
        const imported = JSON.parse(exported);
        
        assertEquals(imported.name, workflow.name);
      }
    );
    
    testSuite.test('e2e', 'Multi-Step Workflow with Variables',
      'Should handle workflows with variable substitution',
      async () => {
        const variables = { name: 'flux', version: '1.0' };
        const command = 'echo "{{name}} version {{version}}"';
        
        const result = command.replace(/\{\{(\w+)\}\}/g, (_, key) => variables[key]);
        assert(result.includes('flux'));
        assert(result.includes('1.0'));
      }
    );
    
    testSuite.test('e2e', 'Workflow Cancellation',
      'Should cancel running workflows',
      async () => {
        let cancelled = false;
        const cancel = () => cancelled = true;
        
        cancel();
        assert(cancelled);
      }
    );
    
    // ============================================
    // PERFORMANCE TESTS
    // ============================================
    
    testSuite.test('performance', 'Search Performance (1000 items)',
      'Should search 1000 items in <200ms',
      async () => {
        const items = Array.from({ length: 1000 }, (_, i) => `item-${i}`);
        const start = performance.now();
        
        const results = items.filter(item => item.includes('99'));
        
        const duration = performance.now() - start;
        assert(duration < 200, `Search took ${duration}ms, expected <200ms`);
        assert(results.length > 0);
      }
    );
    
    testSuite.test('performance', 'JSON Parse Performance',
      'Should parse large JSON in <100ms',
      async () => {
        const data = JSON.stringify({ workflows: Array.from({ length: 100 }, (_, i) => ({
          name: `Workflow ${i}`,
          steps: []
        }))});
        
        const start = performance.now();
        const parsed = JSON.parse(data);
        const duration = performance.now() - start;
        
        assert(duration < 100, `Parse took ${duration}ms, expected <100ms`);
        assert(parsed.workflows.length === 100);
      }
    );
    
    testSuite.test('performance', 'DOM Manipulation Performance',
      'Should create 100 elements in <50ms',
      async () => {
        const container = document.createElement('div');
        const start = performance.now();
        
        for (let i = 0; i < 100; i++) {
          const el = document.createElement('div');
          el.textContent = `Item ${i}`;
          container.appendChild(el);
        }
        
        const duration = performance.now() - start;
        assert(duration < 50, `DOM ops took ${duration}ms, expected <50ms`);
        assertEquals(container.children.length, 100);
      }
    );
    
    testSuite.test('performance', 'Memory Usage Check',
      'Should not leak memory',
      async () => {
        if (performance.memory) {
          const before = performance.memory.usedJSHeapSize;
          
          // Create and destroy objects
          const arr = Array.from({ length: 1000 }, (_, i) => ({ id: i }));
          arr.length = 0;
          
          const after = performance.memory.usedJSHeapSize;
          const growth = after - before;
          
          assert(growth < 5 * 1024 * 1024, `Memory grew by ${(growth/1024/1024).toFixed(2)}MB`);
        }
      }
    );
    
    testSuite.test('performance', 'Debounce Function',
      'Should debounce function calls',
      async () => {
        let callCount = 0;
        
        const debounce = (fn, delay) => {
          let timeout;
          return (...args) => {
            clearTimeout(timeout);
            timeout = setTimeout(() => fn(...args), delay);
          };
        };
        
        const debouncedFn = debounce(() => callCount++, 100);
        
        // Call multiple times rapidly
        debouncedFn();
        debouncedFn();
        debouncedFn();
        
        // Should only call once after delay
        await new Promise(resolve => setTimeout(resolve, 150));
        assertEquals(callCount, 1);
      }
    );
    
    testSuite.test('performance', 'Memoization Efficiency',
      'Should cache results for performance',
      async () => {
        const cache = new Map();
        
        const memoize = (fn) => {
          return (arg) => {
            if (cache.has(arg)) return cache.get(arg);
            const result = fn(arg);
            cache.set(arg, result);
            return result;
          };
        };
        
        const expensiveFn = (n) => n * n;
        const memoized = memoize(expensiveFn);
        
        const start1 = performance.now();
        memoized(100);
        const duration1 = performance.now() - start1;
        
        const start2 = performance.now();
        memoized(100); // Should be cached
        const duration2 = performance.now() - start2;
        
        assert(duration2 < duration1 || duration2 < 1, 'Cached call should be faster');
      }
    );
    
    // Initialize UI
    window.addEventListener('DOMContentLoaded', () => {
      testSuite.renderAllTests();
      testSuite.updateBadges();
      
      // Filter buttons
      document.querySelectorAll('.filter-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          
          const filter = btn.dataset.filter;
          document.querySelectorAll('.test-case').forEach(test => {
            if (filter === 'all') {
              test.style.display = 'block';
            } else {
              const status = test.querySelector('.test-status');
              test.style.display = status?.classList.contains(filter) ? 'block' : 'none';
            }
          });
        });
      });
    });
    
    // Global functions
    async function runAllTests() {
      await testSuite.runTests();
    }
    
    async function runUnitTests() {
      await testSuite.runTests('unit');
    }
    
    async function runIntegrationTests() {
      await testSuite.runTests('integration');
    }
    
    async function runE2ETests() {
      await testSuite.runTests('e2e');
    }
    
    async function runPerformanceTests() {
      await testSuite.runTests('performance');
    }
    
    function clearResults() {
      testSuite.tests.forEach(test => {
        test.status = 'pending';
        test.result = null;
        test.duration = 0;
      });
      testSuite.results = { total: 0, passed: 0, failed: 0, skipped: 0, duration: 0 };
      testSuite.renderAllTests();
      testSuite.updateSummary();
      document.getElementById('progress-fill').style.width = '0%';
    }
    
    console.log('ðŸ§ª Test Suite Ready - 30+ tests loaded');
    console.log('Run runAllTests() to start testing');
  </script>
</body>
</html>
