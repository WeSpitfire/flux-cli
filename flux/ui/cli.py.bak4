"""CLI interface for Flux."""

import sys
from pathlib import Path
from typing import Optional, List
from rich.console import Console
from rich.panel import Panel

from flux.core.config import Config
from flux.core.project import ProjectDetector, ProjectInfo
from flux.core.memory import MemoryStore
from flux.core.undo import UndoManager
from flux.core.workflow import WorkflowEnforcer
from flux.core.approval import ApprovalManager
from flux.core.git_utils import GitIntegration
from flux.core.codebase_intelligence import CodebaseGraph
from flux.core.impact_analyzer import ImpactAnalyzer
from flux.core.suggestions import SuggestionsEngine, Priority
from flux.core.workspace import Workspace, TaskPriority, TaskStatus
from flux.core.failure_tracker import FailureTracker
from flux.core.background_processor import SmartBackgroundProcessor
from flux.core.code_validator import CodeValidator
from flux.core.debug_logger import DebugLogger
from flux.core.state_tracker import ProjectStateTracker
from flux.core.error_parser import ErrorParser
from flux.core.test_runner import TestRunner, TestResult
from flux.core.test_watcher import TestWatcher
from flux.core.auto_fixer import AutoFixer
from flux.core.auto_fix_watcher import AutoFixWatcher, AutoFixEvent
from flux.core.orchestrator import AIOrchestrator
from flux.core.orchestrator_tools import register_all_tools
from flux.core.auto_init import auto_initialize
from flux.core.task_planner import TaskPlanner
from flux.ui.nl_commands import get_parser
from flux.llm.provider_factory import create_provider
from flux.tools.base import ToolRegistry
from flux.tools.file_ops import ReadFilesTool, WriteFileTool, EditFileTool, MoveFileTool, DeleteFileTool
from flux.tools.command import RunCommandTool
from flux.tools.search import GrepSearchTool
from flux.tools.filesystem import ListFilesTool, FindFilesTool
from flux.tools.ast_edit import ASTEditTool
from flux.tools.validation import ValidationTool
from flux.tools.preview import PreviewEditTool
from flux.tools.line_insert import InsertAtLineTool
from flux.ui.display_manager import DisplayManager
from flux.ui.command_router import CommandRouter


class CLI:
    """Main CLI interface for Flux."""

    def __init__(self, config: Config, cwd: Path):
        """Initialize CLI."""
        self.config = config
        self.cwd = cwd

        # Initialize display manager
        self.display = DisplayManager()

        # Keep console for backward compatibility (will be removed in Phase 5)
        import sys
        self.console = Console(file=sys.stdout, force_terminal=False)
        self.llm = create_provider(config)

        # Initialize command router (will be set after all dependencies initialized)
        self.commands: Optional[CommandRouter] = None

        # Detect project
        self.project_info = ProjectDetector(cwd).detect()

        # Initialize memory store
        self.memory = MemoryStore(config.flux_dir, cwd)

        # Initialize undo manager
        self.undo = UndoManager(config.flux_dir, cwd)

        # Initialize workflow enforcer
        # Enable strict mode for small context models (Haiku) to enforce read-before-write
        strict_mode = "haiku" in config.model.lower() or "gpt-3.5" in config.model.lower()
        self.workflow = WorkflowEnforcer(cwd, strict_mode=strict_mode)

        # Initialize approval manager
        self.approval = ApprovalManager(auto_approve=config.auto_approve)

        # Initialize git integration
        self.git = GitIntegration(cwd)

        # Initialize codebase intelligence (lazy loading)
        self.codebase_graph: Optional[CodebaseGraph] = None
        self._graph_building = False
        self._project_readme: Optional[str] = None

        # Initialize impact analyzer (lazy loading)
        self.impact_analyzer: Optional[ImpactAnalyzer] = None

        # Initialize suggestions engine (lazy loading)
        self.suggestions_engine: Optional[SuggestionsEngine] = None

        # Initialize workspace manager
        workspace_dir = config.flux_dir / "workspace"
        self.workspace: Workspace = Workspace(workspace_dir, cwd)

        # Initialize failure tracker
        self.failure_tracker = FailureTracker()

        # Initialize tool success tracker for metrics
        from flux.core.tool_metrics import ToolSuccessTracker
        metrics_path = config.flux_dir / "tool_metrics.json"
        self.tool_metrics = ToolSuccessTracker(storage_path=metrics_path)

        # Initialize smart background processor
        self.bg_processor = SmartBackgroundProcessor(cwd)

        # Initialize code validator for self-checking
        self.code_validator = CodeValidator(cwd)

        # Initialize debug logger (disabled by default)
        self.debug_logger = DebugLogger(config.flux_dir, enabled=False)

        # Initialize project state tracker for contextual awareness
        self.state_tracker = ProjectStateTracker(cwd)

        # Initialize natural language command parser
        self.nl_parser = get_parser()

        # Initialize error parser for smart error detection
        self.error_parser = ErrorParser(cwd)

        # Initialize test runner and watcher
        self.test_runner = TestRunner(cwd)
        self.test_watcher: Optional[TestWatcher] = None

        # Initialize auto-fixer (enabled by default)
        self.auto_fixer = AutoFixer(cwd, enabled=True)
        self.auto_fix_watcher: Optional[AutoFixWatcher] = None

        # Initialize tool registry
        self.tools = ToolRegistry()
        self.tools.register(ReadFilesTool(cwd, workflow_enforcer=self.workflow, background_processor=self.bg_processor))
        self.tools.register(WriteFileTool(cwd, undo_manager=self.undo, workflow_enforcer=self.workflow, approval_manager=self.approval, code_validator=self.code_validator))
        self.tools.register(EditFileTool(cwd, undo_manager=self.undo, workflow_enforcer=self.workflow, approval_manager=self.approval, code_validator=self.code_validator))
        self.tools.register(MoveFileTool(cwd, undo_manager=self.undo, workflow_enforcer=self.workflow, approval_manager=self.approval))
        self.tools.register(DeleteFileTool(cwd, undo_manager=self.undo, workflow_enforcer=self.workflow, approval_manager=self.approval))
        self.tools.register(InsertAtLineTool(cwd, undo_manager=self.undo, workflow_enforcer=self.workflow, approval_manager=self.approval))
        self.tools.register(PreviewEditTool(cwd))
        self.tools.register(RunCommandTool(cwd))
        self.tools.register(GrepSearchTool(cwd, workflow_enforcer=self.workflow))
        self.tools.register(ListFilesTool(cwd))
        self.tools.register(FindFilesTool(cwd))

        # Don't register ast_edit for small context models (high failure rate)
        if "haiku" not in config.model.lower() and "gpt-3.5" not in config.model.lower():
            self.tools.register(ASTEditTool(cwd, undo_manager=self.undo, workflow_enforcer=self.workflow, approval_manager=self.approval))

        self.tools.register(ValidationTool(cwd))

        # Initialize AI Orchestrator
        self.orchestrator = AIOrchestrator(self.llm, cwd)
        # Register all tools with orchestrator
        register_all_tools(self.orchestrator, self)

        # Initialize Smart Task Planner for autonomous decomposition
        self.task_planner: Optional[TaskPlanner] = None  # Lazy init after graph built

        # Initialize Session Manager
        from flux.core.session_manager import SessionManager, EventType
        self.session_manager = SessionManager(cwd)
        self.EventType = EventType  # Store for easy access

        # Initialize Proactive Monitor
        from flux.core.proactive_monitor import ProactiveMonitor, MonitorType
        self.proactive_monitor = ProactiveMonitor(cwd, self.llm)
        self.proactive_monitor.add_notification_callback(self._print_monitor_notification)
        self.MonitorType = MonitorType  # Store for easy access

        # Initialize Workflow Manager and Executor
        from flux.core.workflows import WorkflowManager, WorkflowExecutor
        self.workflow_manager = WorkflowManager(cwd)
        self.workflow_executor = WorkflowExecutor(self.orchestrator)
        self.workflow_executor.add_notification_callback(self._print_monitor_notification)

        # Initialize Command Suggestion Engine
        from flux.core.command_suggestions import CommandSuggestionEngine
        self.command_suggester = CommandSuggestionEngine(
            session_manager=self.session_manager,
            state_tracker=self.state_tracker,
            git=self.git,
            proactive_monitor=self.proactive_monitor,
            workflow_manager=self.workflow_manager
        )

        # Input blocking state for preventing mid-stream commands
        self._llm_processing = False
        self._processing_cancelled = False

        # Initialize command router NOW (all dependencies ready)
        self.commands = CommandRouter(self)

        # Initialize conversation manager for query processing
        from flux.core.conversation_manager import ConversationManager
        self.conversation = ConversationManager(self)

        # Initialize workflow coordinator for task planning and orchestration
        from flux.core.workflow_coordinator import WorkflowCoordinator
        self.workflow_coord = WorkflowCoordinator(self)

        # Initialize Git/Test manager for Git and testing operations
        from flux.core.git_test_manager import GitTestManager
        self.git_test = GitTestManager(self)

        # Initialize codebase analyzer for analysis and architecture features
        from flux.core.codebase_analyzer import CodebaseAnalyzer
        self.codebase_analyzer = CodebaseAnalyzer(self)

    async def build_codebase_graph(self) -> None:
        """Build the codebase semantic graph (runs in background)."""
        if self._graph_building or self.codebase_graph:
            return

        self._graph_building = True
        try:
            self.console.print("[dim]Building codebase graph...[/dim]")
            self.codebase_graph = CodebaseGraph(self.cwd)
            self.codebase_graph.build_graph(max_files=500)  # Limit for performance

            # Show architecture detection results
            patterns = self.codebase_graph.detect_architecture_patterns()
            if patterns.get('framework'):
                self.console.print(f"[dim]Detected: {patterns['framework']} ({patterns['structure']} structure)[/dim]")

            # Auto-read README for project understanding
            self._project_readme = await self._load_readme()

            # Initialize impact analyzer with graph
            self.impact_analyzer = ImpactAnalyzer(self.cwd, self.codebase_graph)

            # Initialize suggestions engine with graph
            self.suggestions_engine = SuggestionsEngine(self.cwd, self.codebase_graph)

            # Initialize task planner with graph
            self.task_planner = TaskPlanner(self.llm, self.codebase_graph)
        except Exception as e:
            self.console.print(f"[yellow]Warning: Could not build code graph: {e}[/yellow]")
        finally:
            self._graph_building = False

    async def _load_readme(self) -> Optional[str]:
        """Load README file for project understanding."""
        readme_files = ['README.md', 'README.txt', 'README.rst', 'README']
        for readme_name in readme_files:
            readme_path = self.cwd / readme_name
            if readme_path.exists():
                try:
                    with open(readme_path, 'r', encoding='utf-8') as f:
                        content = f.read()
                        # Limit to first 5000 chars to avoid token bloat
                        return content[:5000] if len(content) > 5000 else content
                except Exception:
                    pass
        return None

    def get_intelligent_context(self, query: str) -> List[str]:
        """Get intelligent file suggestions based on query."""
        if not self.codebase_graph:
            return []

        suggested_files = self.codebase_graph.suggest_context_files(query, max_files=3)
        return suggested_files

    def print_banner(self):
        """Print Flux banner."""
        # Load/resume session
        last_session = self.session_manager.load_last_session()
        session_summary = None
        if last_session:
            session_summary = self.session_manager.get_session_summary(last_session)
        else:
            self.session_manager.start_new_session()

        # Get current task for legacy support
        current_task = None
        if self.memory.state.current_task and not last_session:
            current_task = self.memory.state.current_task

        # Delegate to display manager
        self.display.print_banner(
            cwd=self.cwd,
            config=self.config,
            project_info=self.project_info,
            session_summary=session_summary,
            current_task=current_task
        )

    async def run_interactive(self):
        """Run interactive REPL mode."""
        self.print_banner()

        # Smart auto-initialization based on project context
        await auto_initialize(self)

        # Multi-line compose state (disabled if not truly interactive)
        import sys
        self._enable_paste_mode = sys.stdin.isatty()  # Only enable for real terminals
        self._compose_mode = False
        self._compose_buffer = []  # type: list[str]
        self._last_input_time = 0.0  # Track timing for paste detection

        self.display.print_help_text()

        while True:
            try:
                # Show contextual suggestions before prompt (only in interactive mode)
                if self._enable_paste_mode:
                    self._maybe_show_suggestions()

                # Auto-clear context when it gets too full (invisible to user)
                # CRITICAL FIX: Check conversation history size, NOT cumulative API usage!
                conversation_tokens = self.llm.estimate_conversation_tokens()
                usage_percent = (conversation_tokens / self.config.max_history) * 100 if self.config.max_history > 0 else 0

                # Emergency circuit breaker: Hard stop at 150% to prevent rate limit errors
                if conversation_tokens > (self.config.max_history * 1.5):
                    # CRITICAL: Context has grown way too large, clear immediately
                    current_task = self.memory.state.current_task
                    self.llm.clear_history()
                    if current_task:
                        self.memory.state.current_task = current_task
                    self.display.print_emergency_context_clear(conversation_tokens)
                    continue  # Skip this iteration, show prompt again

                if usage_percent >= 90:
                    # Auto-clear to prevent errors - but preserve important context
                    old_token_count = conversation_tokens

                    # Save current task before clearing
                    current_task = self.memory.state.current_task

                    # Clear conversation history
                    self.llm.clear_history()

                    # Restore task context in a fresh message if there was one
                    if current_task:
                        # Add it back as system context (not as a user message)
                        self.memory.state.current_task = current_task

                    self.display.print_context_cleared(old_token_count)

                # BLOCK INPUT if LLM is processing
                if self._llm_processing:
                    self.display.print_processing_blocker()
                    # Show a persistent indicator until processing completes
                    import asyncio
                    while self._llm_processing:
                        await asyncio.sleep(0.1)
                    # After processing completes, show prompt again
                    self.display.print_processing_ready()

                # Get user input
                query = self.display.prompt_user(enable_paste_mode=self._enable_paste_mode)

                # Decode newline placeholders from desktop app
                if '<<<NEWLINE>>>' in query:
                    query = query.replace('<<<NEWLINE>>>', '\n')

                # Try to parse natural language commands
                nl_result = self.nl_parser.parse(query)
                if nl_result:
                    command, args = nl_result
                    # Show what we interpreted
                    self.display.print_nl_command_interpretation(command, args)
                    # Rewrite query as the slash command
                    if args:
                        query = f"{command} {args}"
                    else:
                        query = command

                if query.lower() in ['exit', 'quit', 'q']:
                    self.display.print_goodbye()
                    break

                # Handle slash commands via CommandRouter
                if query.startswith('/'):
                    handled = await self.commands.handle(query)
                    if handled:
                        continue

                # Paste mode handling (only if enabled for interactive terminals)
                    # Check if there are any recent errors
                    recent_commands = [c for c in self.state_tracker.command_history[-5:] if c.exit_code != 0]

                    if not recent_commands:
                        self.console.print("[yellow]No recent failed commands to fix.[/yellow]")
                        continue

                    # Get the most recent failed command
                    last_failed = recent_commands[-1]

                    # Parse errors
                    parsed_errors = self.error_parser.parse_output(last_failed.output or "", last_failed.command)

                    if not parsed_errors:
                        self.console.print(f"[yellow]No parseable errors found in: {last_failed.command}[/yellow]")
                        continue

                    # Show errors
                    self.console.print(f"\n[bold]üõ†Ô∏è  Analyzing Errors from:[/bold] [cyan]{last_failed.command}[/cyan]\n")

                    for i, error in enumerate(parsed_errors[:3], 1):
                        self.console.print(f"{i}. {self.error_parser.format_error(error)}\n")

                    # Get fix context for first error
                    first_error = parsed_errors[0]
                    fix_context = self.error_parser.get_fix_context(first_error)

                    if fix_context:
                        # Automatically ask Flux to fix it
                        fix_query = (
                            f"Fix this error:\n\n"
                            f"Error: {first_error.error_type}: {first_error.message}\n"
                            f"File: {fix_context['file_path']}:{fix_context['line_number']}\n\n"
                            f"Code context (lines {fix_context['start_line']}-{fix_context['end_line']}):\n"
                            f"```\n{fix_context['code_context']}```\n\n"
                            f"Please fix this error."
                        )

                        self.console.print("[dim]‚Üí Asking Flux to fix the error...[/dim]\n")

                        # Process as a query
                        query = fix_query
                        # Let it continue to the main processing logic
                    else:
                        self.console.print(f"[yellow]Could not get fix context for {first_error.file_path}[/yellow]")
                        continue

                if query.lower() == '/state':
                    summary = self.state_tracker.get_context_summary(max_age_minutes=30)
                    suggestions = self.state_tracker.get_proactive_suggestions()

                    self.console.print("\n[bold]üß† Project State (Last 30 minutes):[/bold]\n")

                    # Files
                    if summary['files']['recently_modified']:
                        self.console.print(f"[bold cyan]Recent Files:[/bold cyan]")
                        for f in summary['files']['recently_modified'][:5]:
                            self.console.print(f"  ‚Ä¢ {f}")
                        self.console.print()

                    if summary['files']['most_active']:
                        self.console.print(f"[bold cyan]Hot Files:[/bold cyan]")
                        for f, count in summary['files']['most_active']:
                            self.console.print(f"  ‚Ä¢ {f} ({count} modifications)")
                        self.console.print()

                    # Git
                    if summary['git']['is_repo']:
                        self.console.print(f"[bold cyan]Git:[/bold cyan]")
                        self.console.print(f"  Branch: {summary['git']['branch']}")
                        if summary['git']['has_changes']:
                            self.console.print(f"  Changes: {summary['git']['total_changes']} files (" +
                                             f"{summary['git']['staged_files']} staged, " +
                                             f"{summary['git']['modified_files']} modified, " +
                                             f"{summary['git']['untracked_files']} untracked)")
                        else:
                            self.console.print("  Clean working directory")
                        self.console.print()

                    # Tests
                    if summary['tests']['recent_count'] > 0:
                        self.console.print(f"[bold cyan]Tests:[/bold cyan]")
                        if summary['tests']['last_passed'] is not None:
                            status = "[green]‚úì Passed[/green]" if summary['tests']['last_passed'] else "[red]‚úó Failed[/red]"
                            self.console.print(f"  Last run: {status}")
                        if summary['tests']['recent_failures']:
                            self.console.print(f"  Failures:")
                            for failure in summary['tests']['recent_failures'][:3]:
                                self.console.print(f"    ‚Ä¢ {failure}")
                        self.console.print()

                    # Commands
                    if summary['commands']['recent_count'] > 0:
                        self.console.print(f"[bold cyan]Commands:[/bold cyan]")
                        self.console.print(f"  Recent: {summary['commands']['recent_count']}")
                        if summary['commands']['last_command']:
                            self.console.print(f"  Last: {summary['commands']['last_command']}")
                        if summary['commands']['failed_commands']:
                            self.console.print(f"  Failed: {len(summary['commands']['failed_commands'])}")
                        self.console.print()

                    # Suggestions
                    if suggestions:
                        self.console.print(f"[bold yellow]üí° Suggestions:[/bold yellow]")
                        for suggestion in suggestions:
                            self.console.print(f"  {suggestion}")
                        self.console.print()
                    else:
                        self.console.print("[dim]No suggestions - you're doing great! üöÄ[/dim]\n")

                    continue

                # -- Session commands --
                if query.lower() == '/session':
                    # Show current session summary
                    current = self.session_manager.get_current_session()
                    if current:
                        summary = self.session_manager.get_session_summary(current)
                        self.console.print("\n" + summary)
                    else:
                        self.console.print("[yellow]No active session[/yellow]")
                    continue

                # -- Workflow commands --
                if query.lower() == '/workflows':
                    # List available workflows
                    workflows = self.workflow_manager.list_workflows()
                    if not workflows:
                        self.console.print("[yellow]No workflows defined. Create `.flux/workflows.yaml` to add workflows.[/yellow]")
                    else:
                        self.console.print("\n[bold]Available Workflows:[/bold]")
                        for wf in workflows:
                            workflow = self.workflow_manager.get_workflow(wf)
                            desc = workflow.get('description', 'No description')
                            self.console.print(f"  [cyan]{wf}[/cyan] - {desc}")
                        self.console.print("\nUse `/workflow <name>` to execute a workflow.")
                    continue

                if query.lower().startswith('/workflow '):
                    # Execute a workflow
                    workflow_name = query[10:].strip()
                    if not workflow_name:
                        self.console.print("[red]Usage: /workflow <name>[/red]")
                        continue

                    try:
                        workflow = self.workflow_manager.get_workflow(workflow_name)
                        self.console.print(f"\n[bold]Executing workflow: {workflow_name}[/bold]\n")

                        # Execute workflow asynchronously
                        import asyncio
                        result = asyncio.run(self.workflow_executor.execute(workflow))

                        if result.get('success'):
                            self.console.print(f"\n[green]‚úì Workflow '{workflow_name}' completed successfully[/green]")
                        else:
                            error = result.get('error', 'Unknown error')
                            self.console.print(f"\n[red]‚úó Workflow '{workflow_name}' failed: {error}[/red]")

                        # Record workflow execution
                        self.session_manager.record_event(
                            self.EventType.WORKFLOW_EXECUTED,
                            {'workflow': workflow_name, 'success': result.get('success', False)}
                        )
                    except Exception as e:
                        self.console.print(f"[red]Error executing workflow: {e}[/red]")
                    continue

                # -- Monitoring commands --
                if query.lower().startswith('/watch'):
                    parts = query.split()
                    if len(parts) < 2:
                        self.console.print("[yellow]Usage: /watch <type> or /watch stop[/yellow]")
                        self.console.print("Types: tests, lint, build, files, git, all")
                        continue

                    action = parts[1].lower()

                    if action == 'stop':
                        self.proactive_monitor.stop()
                        self.console.print("[yellow]All monitors stopped[/yellow]")
                    elif action == 'all':
                        import asyncio
                        for monitor_type in self.MonitorType:
                            self.proactive_monitor.enable_monitor(monitor_type)
                        asyncio.create_task(self.proactive_monitor.start())
                        self.console.print("[green]All monitors started[/green]")
                    else:
                        try:
                            # Map string to MonitorType
                            type_map = {
                                'tests': self.MonitorType.TESTS,
                                'lint': self.MonitorType.LINT,
                                'build': self.MonitorType.BUILD,
                                'files': self.MonitorType.FILE_CHANGES,
                                'git': self.MonitorType.GIT_CHANGES
                            }
                            monitor_type = type_map.get(action)
                            if not monitor_type:
                                self.console.print(f"[red]Unknown monitor type: {action}[/red]")
                                continue

                            import asyncio
                            self.proactive_monitor.enable_monitor(monitor_type)
                            asyncio.create_task(self.proactive_monitor.start())
                            self.console.print(f"[green]Started {action} monitor[/green]")
                        except Exception as e:
                            self.console.print(f"[red]Error starting monitor: {e}[/red]")
                    continue

                if query.lower() == '/status':
                    # Show monitor status
                    status = self.proactive_monitor.get_status()
                    self.console.print("\n[bold]Monitor Status:[/bold]")
                    self.console.print(f"  Running: {'Yes' if status['running'] else 'No'}")
                    self.console.print(f"  Active monitors: {len(status['active_monitors'])}")
                    if status['active_monitors']:
                        for monitor in status['active_monitors']:
                            self.console.print(f"    - {monitor}")
                    if status['last_events']:
                        self.console.print("\n[bold]Recent Events:[/bold]")
                        for event in status['last_events'][-5:]:  # Show last 5
                            self.console.print(f"  [{event['timestamp']}] {event['type']}: {event.get('message', 'N/A')}")
                    continue

                # -- Auto-approve toggle --
                if query.lower() == '/auto-approve':
                    # Toggle auto-approve mode
                    self.approval.auto_approve = not self.approval.auto_approve
                    status = "enabled" if self.approval.auto_approve else "disabled"
                    color = "green" if self.approval.auto_approve else "yellow"
                    self.console.print(f"[{color}]Auto-approve {status}[/{color}]")
                    if self.approval.auto_approve:
                        self.console.print("[dim]All file changes will be applied automatically without prompts[/dim]")
                    else:
                        self.console.print("[dim]You'll be prompted to approve each file change[/dim]")
                    continue

                # -- Smart suggestions command --
                if query.lower() == '/suggest':
                    # Show contextual command suggestions
                    suggestions = self.command_suggester.get_suggestions(max_suggestions=5)
                    if suggestions:
                        self.console.print("\n[bold]üí° Suggested Commands:[/bold]")
                        for i, sug in enumerate(suggestions, 1):
                            self.console.print(f"  {i}. {sug.format()}")
                        self.console.print()
                    else:
                        self.console.print("\n[dim]No suggestions at the moment - you're doing great! üöÄ[/dim]\n")
                    continue

                if query.lower() == '/help':
                    help_text = (
                        "[bold]Available Commands:[/bold]\n"
                        "\n[bold magenta]‚ú® Natural Language:[/bold magenta]\n"
                        "  Just ask naturally! Examples:\n"
                        "  [dim]‚Ä¢ 'show me what changed' ‚Üí /diff[/dim]\n"
                        "  [dim]‚Ä¢ 'run the tests' ‚Üí /test[/dim]\n"
                        "  [dim]‚Ä¢ 'undo that' ‚Üí /undo[/dim]\n"
                        "  [dim]‚Ä¢ 'what's happening' ‚Üí /state[/dim]\n"
                        "\n[bold cyan]General:[/bold cyan]\n"
                        "  [green]/help[/green] - Show this help message\n"
                        "  [green]/model[/green] - Show current provider and model\n"
                        "  [green]/history[/green] - Show conversation history summary\n"
                        "  [green]/clear[/green] - Clear conversation history\n"
                        "\n[bold cyan]Multi-line & Paste Mode:[/bold cyan]\n"
                        "  [green]/paste[/green] or [green]```[/green] - Start paste mode\n"
                        "  [green]/end[/green] or [green]/send[/green] or [green]```[/green] - Finish and send\n"
                        "  [green]/discard[/green] - Cancel paste mode and discard\n"
                        "  Tip: Paste large tasks as a single block; Flux auto-detects lists and will enter paste mode.\n"
                        "\n[bold cyan]Session & Context:[/bold cyan]\n"
                        "  [green]/session[/green] - Show current session summary\n"
                        "  [green]/task <description>[/green] - Set current task\n"
                        "  [green]/memory[/green] - Show project memory\n"
                        "  [green]/checkpoint <msg>[/green] - Save a checkpoint\n"
                        "  [green]/project[/green] - Show files created in this session\n"
                        "\n[bold cyan]Workflows & Automation:[/bold cyan]\n"
                        "  [green]/workflows[/green] - List available workflows\n"
                        "  [green]/workflow <name>[/green] - Execute a workflow\n"
                        "  [green]/watch <type>[/green] - Start monitoring (tests/lint/build/files/git/all)\n"
                        "  [green]/watch stop[/green] - Stop all monitors\n"
                        "  [green]/status[/green] - Show monitor status\n"
                        "  [green]/suggest[/green] - Get smart command suggestions based on context\n"
                        "\n[bold cyan]Undo Commands:[/bold cyan]\n"
                        "  [green]/undo[/green] - Undo last file operation\n"
                        "  [green]/undo-history[/green] - Show undo history\n"
                        "\n[bold cyan]Git & Testing:[/bold cyan]\n"
                        "  [green]/diff[/green] - Show git diff of changes\n"
                        "  [green]/commit[/green] - Smart commit with generated message\n"
                        "  [green]/test[/green] - Run project tests\n"
                        "  [green]/watch[/green] - Start test watch mode (auto-run on file changes)\n"
                        "  [green]/watch-stop[/green] - Stop test watch mode\n"
                        "\n[bold cyan]Workflow & Approval:[/bold cyan]\n"
                        "  [green]/workflow[/green] - Show workflow status\n"
                        "  [green]/approval[/green] - Show approval statistics\n"
                        "  [green]/auto-approve[/green] - Toggle auto-approve mode (skip file change prompts)\n"
                        "\n[bold cyan]Codebase Intelligence:[/bold cyan]\n"
                        "  [green]/index[/green] - Build semantic codebase graph\n"
                        "  [green]/related <file|query>[/green] - Find related files\n"
                        "  [green]/architecture[/green] - Show detected architecture\n"
                        "  [green]/preview <file>[/green] - Preview impact of modifying a file\n"
                        "  [green]/suggest[/green] - Get proactive AI suggestions\n"
                        "\n[bold cyan]Workspace Intelligence:[/bold cyan]\n"
                        "  [green]/session save <n>[/green] - Save current work session\n"
                        "  [green]/session restore <id>[/green] - Restore a saved session\n"
                        "  [green]/sessions[/green] - List all sessions\n"
                        "  [green]/newtask <title>[/green] - Create a new task\n"
                        "  [green]/tasks[/green] - List all tasks\n"
                        "  [green]/summary[/green] - Show work summary for today\n"
                        "  [green]/stats[/green] - Show project statistics\n"
                        "  [green]/performance[/green] (or [green]/perf[/green]) - Show background processing stats\n"
                        "\n[bold cyan]Code Quality:[/bold cyan]\n"
                        "  [green]/validate[/green] - Validate modified files for errors\n"
                        "  [green]/fix[/green] - Auto-detect and fix recent errors\n"
                        "\n[bold cyan]Debug & Diagnostics:[/bold cyan]\n"
                        "  [green]/debug-on[/green] - Enable debug logging\n"
                        "  [green]/debug-off[/green] - Disable debug logging\n"
                        "  [green]/debug[/green] - Show debug session summary\n"
                        "  [green]/debug-analyze <issue>[/green] - Analyze logs for an issue\n"
                        "  [green]/inspect[/green] - Inspect current conversation state\n"
                    )
                    # Use plain text title to avoid Unicode issues in piped output
                    self.console.print(Panel(help_text, title="Help", border_style="blue"))
                    continue


                if query.lower() == '/model':
                    self.console.print(
                        f"\n[bold]ü§ñ Current Model:[/bold]\n"
                        f"  Provider: [cyan]{self.config.provider}[/cyan]\n"
                        f"  Model: [cyan]{self.config.model}[/cyan]\n"
                    )
                    continue

                # Paste mode handling (only if enabled for interactive terminals)
                import time
                current_time = time.time()

                if getattr(self, "_enable_paste_mode", True) and getattr(self, "_compose_mode", False):
                    # Check for explicit end commands
                    if query.strip() in ('/end', '/send', '```'):
                        combined = "\n".join(self._compose_buffer).strip()
                        self._compose_mode = False
                        self._compose_buffer = []
                        if not combined:
                            self.console.print("[dim]Nothing to send[/dim]")
                            continue
                        query = combined
                    elif query.strip() == '/discard':
                        self._compose_mode = False
                        self._compose_buffer = []
                        self.console.print("[yellow]Discarded paste buffer[/yellow]")
                        continue
                    elif not query.strip():
                        # Empty line after paste - auto-send if buffer has content
                        if self._compose_buffer and (current_time - self._last_input_time) > 0.5:
                            combined = "\n".join(self._compose_buffer).strip()
                            self._compose_mode = False
                            self._compose_buffer = []
                            query = combined
                        else:
                            # Still pasting - skip empty line
                            self._last_input_time = current_time
                            continue
                    else:
                        # Accumulate silently
                        self._compose_buffer.append(query)
                        self._last_input_time = current_time
                        continue

                # Manual paste mode start
                if query.strip() in ('/paste', '```'):
                    self._compose_mode = True
                    self._compose_buffer = []
                    self._last_input_time = current_time
                    self.console.print("[dim]Paste mode - press Enter twice when done[/dim]")
                    continue

                # Skip empty input in normal mode
                if not query.strip():
                    continue

                # Auto-detect paste: if input looks like start of multi-line, enter silent mode
                # Only enable if running in interactive terminal (not piped/desktop app)
                import re
                if getattr(self, "_enable_paste_mode", True) and (re.match(r"^(\s*\d+\.|\s*[-*])\s+", query) or (query.rstrip().endswith(':') and len(query) > 10)):
                    self._compose_mode = True
                    self._compose_buffer = [query]
                    self._last_input_time = current_time
                    continue

                # Process query
                await self.process_query(query)

            except KeyboardInterrupt:
                # If we're processing, cancel it. Otherwise, exit.
                if self._llm_processing:
                    self._processing_cancelled = True
                    self._llm_processing = False
                    self.console.print("\n[yellow]‚èπÔ∏è  Operation cancelled[/yellow]")
                    # Clear any partial state
                    continue
                else:
                    self.console.print("\n[cyan]Goodbye![/cyan]")
                    break
            except Exception as e:
                self.console.print(f"\n[red]Error: {e}[/red]")

    async def run_single_query(self, query: str):
        """Run a single query and exit."""
        # Build graph before processing (don't wait)
        import asyncio
        asyncio.create_task(self.build_codebase_graph())

        await self.process_query(query)

        # Show token usage
        self._show_token_usage()

    async def process_with_task_planner(self, query: str):
        """Process query using task planner - delegates to WorkflowCoordinator."""
        await self.workflow_coord.process_with_task_planner(query)

    async def process_with_orchestrator(self, query: str):
        """Process query using orchestrator - delegates to WorkflowCoordinator."""
        await self.workflow_coord.process_with_orchestrator(query)

    def should_use_orchestrator(self, query: str) -> bool:
        """Determine if orchestrator should be used - delegates to WorkflowCoordinator."""
        return self.workflow_coord.should_use_orchestrator(query)

    async def process_query(self, query: str):
        """Process a user query - delegates to ConversationManager."""
        await self.conversation.process_query(query)

    async def process_query_normal(self, query: str):
        """Process query through normal LLM conversation - delegates to ConversationManager."""
        await self.conversation.process_query_normal(query)

    async def _process_query_normal_impl(self, query: str):
        """Internal implementation - delegates to ConversationManager."""
        await self.conversation._process_query_normal_impl(query)

    async def execute_tool(self, tool_use: dict):
        """Execute a tool - delegates to ConversationManager."""
        await self.conversation.execute_tool(tool_use)

    async def continue_after_tools(self):
        """Continue conversation after tools - delegates to ConversationManager."""
        await self.conversation.continue_after_tools()

    def _get_retry_context(self) -> str:
        """Get retry context warning - delegates to ConversationManager."""
        return self.conversation._get_retry_context()

    def _build_system_prompt(self, query: Optional[str] = None) -> str:
        """Build system prompt - delegates to ConversationManager."""
        return self.conversation._build_system_prompt(query)


    def _print_monitor_notification(self, notification: dict):
        """Callback for proactive monitor notifications."""
        # Handle both string and dict notification formats
        if isinstance(notification, str):
            # Legacy string format - convert to dict
            notification = {'message': notification, 'type': 'info', 'title': 'üí° Notification'}
        self.display.print_monitor_notification(notification)

    def _maybe_show_suggestions(self):
        """Show smart suggestions if there are any relevant ones.

        Only shows suggestions occasionally to avoid spam:
        - After every 3-5 commands
        - When high-confidence suggestions exist (> 0.8)
        """
        # Rate limiting - don't show too often
        if not hasattr(self, '_suggestion_counter'):
            self._suggestion_counter = 0

        self._suggestion_counter += 1

        # Only check every 3-5 commands (with some randomness)
        import random
        check_interval = random.randint(3, 5)

        if self._suggestion_counter < check_interval:
            return

        # Reset counter
        self._suggestion_counter = 0

        # Get suggestions
        try:
            suggestions = self.command_suggester.get_suggestions(max_suggestions=2)

            # Only show high-confidence suggestions automatically
            high_conf_suggestions = [s for s in suggestions if s.confidence >= 0.80]

            if high_conf_suggestions:
                self.console.print("\n[dim]üí° Suggestions:[/dim]")
                for sug in high_conf_suggestions:
                    self.console.print(f"  [dim]{sug.format()}[/dim]")
                self.console.print("[dim]Type /suggest for more suggestions[/dim]")
        except Exception:
            # Silently fail - suggestions are not critical
            pass

    def _show_token_usage(self):
        """Display token usage statistics."""
        usage = self.llm.get_token_usage()

        if usage["total_tokens"] > 0:
            self.console.print()
            self.console.print(
                f"[dim]Tokens: {usage['input_tokens']:,} in / {usage['output_tokens']:,} out "
                f"(total: {usage['total_tokens']:,}) | "
                f"Cost: ${usage['estimated_cost']:.4f}[/dim]"
            )

    async def show_diff(self):
        """Show git diff - delegates to GitTestManager."""
        await self.git_test.show_diff()

    async def smart_commit(self, query: str):
        """Create smart commit - delegates to GitTestManager."""
        await self.git_test.smart_commit(query)

    async def run_tests(self, file_filter: Optional[str] = None):
        """Run tests - delegates to GitTestManager."""
        await self.git_test.run_tests(file_filter)

    def _display_test_result(self, result):
        """Display test results - delegates to GitTestManager."""
        self.git_test.display_test_result(result)

    async def start_watch_mode(self):
        """Start test watch mode - delegates to GitTestManager."""
        await self.git_test.start_watch_mode()

    def stop_watch_mode(self):
        """Stop test watch mode - delegates to GitTestManager."""
        self.git_test.stop_watch_mode()

    def _on_watch_test_complete(self, result):
        """Watch mode callback - delegates to GitTestManager."""
        self.git_test._on_watch_test_complete(result)

    async def show_related_files(self, file_or_query: str):
        """Show files related to a file or query."""
        # Build graph if not built
        if not self.codebase_graph:
            await self.build_codebase_graph()

        if not self.codebase_graph:
            self.console.print("[red]Could not build codebase graph[/red]")
            return

        # Find related files
        related = self.codebase_graph.find_related_files(file_or_query, limit=10)

        if not related:
            self.console.print(f"[yellow]No related files found for '{file_or_query}'[/yellow]")
            return

        self.console.print(f"\n[bold]Related files for '{file_or_query}':[/bold]\n")
        for file_path, score in related:
            # Show file with score indicator
            score_indicator = "üî•" if score > 10 else "üîπ" if score > 5 else "üî∏"
            self.console.print(f"  {score_indicator} [cyan]{file_path}[/cyan] [dim](score: {score:.1f})[/dim]")

            # Show file context
            context = self.codebase_graph.get_file_context(file_path)
            if context.get('entities'):
                entities = context['entities'][:3]  # Show first 3
                for ent in entities:
                    self.console.print(f"     - {ent['type']}: {ent['name']}")

        self.console.print()

    async def show_file_preview(self, file_path: str):
        """Show preview of what would happen if file is modified."""
        if not self.impact_analyzer:
            self.console.print("[yellow]Impact analyzer not available. Run /index first.[/yellow]")
            return

        # Read current file
        full_path = self.cwd / file_path
        if not full_path.exists():
            self.console.print(f"[red]File not found: {file_path}[/red]")
            return

        try:
            with open(full_path, 'r') as f:
                current_content = f.read()
        except Exception as e:
            self.console.print(f"[red]Error reading file: {e}[/red]")
            return

        # Show current file info
        self.console.print(f"\n[bold]Preview for:[/bold] [cyan]{file_path}[/cyan]\n")

        # Get file context from codebase graph
        if self.codebase_graph and file_path in self.codebase_graph.files:
            context = self.codebase_graph.get_file_context(file_path)

            self.console.print(f"[bold]Current State:[/bold]")
            self.console.print(f"  Language: {context.get('language', 'unknown')}")
            self.console.print(f"  Entities: {len(context.get('entities', []))}")

            if context.get('entities'):
                self.console.print(f"\n[bold]Defined in this file:[/bold]")
                for entity in context['entities'][:5]:
                    self.console.print(f"  - {entity['type']}: {entity['name']} (line {entity['line']})")

            if context.get('dependencies'):
                self.console.print(f"\n[bold]Dependencies:[/bold]")
                for dep in context['dependencies'][:3]:
                    self.console.print(f"  ‚Üí {dep}")

            if context.get('dependents'):
                self.console.print(f"\n[bold]Files that depend on this:[/bold]")
                for dep in context['dependents'][:3]:
                    self.console.print(f"  ‚Üê {dep}")
                if len(context['dependents']) > 3:
                    self.console.print(f"  ... and {len(context['dependents']) - 3} more")

        self.console.print(f"\n[dim]To see impact of specific changes, modify the file and Flux will show the analysis.[/dim]")
        self.console.print()

    def show_impact_analysis(self, impact, show_diff: bool = False):
        """Display impact analysis in a beautiful format."""
        from flux.core.impact_analyzer import ImpactLevel

        # Impact level badge
        level_colors = {
            ImpactLevel.LOW: "green",
            ImpactLevel.MEDIUM: "yellow",
            ImpactLevel.HIGH: "red",
            ImpactLevel.CRITICAL: "bold red"
        }
        level_emoji = {
            ImpactLevel.LOW: "üü¢",
            ImpactLevel.MEDIUM: "üü°",
            ImpactLevel.HIGH: "üî¥",
            ImpactLevel.CRITICAL: "‚ö´"
        }

        color = level_colors.get(impact.impact_level, "white")
        emoji = level_emoji.get(impact.impact_level, "‚óã")

        self.console.print(f"\n[bold]üìä Impact Analysis[/bold]")
        self.console.print("=" * 50)

        # Summary
        self.console.print(f"\n[{color}]{emoji} {impact.impact_level.value.upper()}[/{color}] - {impact.change_type.value}")
        self.console.print(f"Confidence: [{self._get_confidence_color(impact.confidence_score)}]{impact.confidence_score * 100:.0f}%[/]")

        # What's affected
        if impact.functions_affected:
            self.console.print(f"\n[bold]Functions:[/bold] {', '.join(impact.functions_affected[:5])}")
            if len(impact.functions_affected) > 5:
                self.console.print(f"  ... and {len(impact.functions_affected) - 5} more")

        if impact.classes_affected:
            self.console.print(f"[bold]Classes:[/bold] {', '.join(impact.classes_affected)}")

        if impact.dependencies_affected:
            self.console.print(f"\n[bold]Dependencies affected:[/bold]")
            for dep in impact.dependencies_affected:
                self.console.print(f"  ‚Üê {dep}")

        # Dependency Impact Tree
        if impact.dependency_tree:
            self._show_dependency_tree(impact)

        # Warnings
        if impact.warnings:
            self.console.print(f"\n[bold yellow]Warnings:[/bold yellow]")
            for warning in impact.warnings:
                self.console.print(f"  {warning}")

        # Suggestions
        if impact.suggestions:
            self.console.print(f"\n[bold cyan]Suggestions:[/bold cyan]")
            for suggestion in impact.suggestions:
                self.console.print(f"  {suggestion}")

        # Risk flags
        if impact.breaks_existing_code:
            self.console.print(f"\n[bold red]‚ö†Ô∏è  May break existing code![/bold red]")
        if impact.requires_migration:
            self.console.print(f"[bold yellow]‚ö†Ô∏è  May require data migration[/bold yellow]")
        if impact.affects_public_api:
            self.console.print(f"[bold yellow]‚ö†Ô∏è  Affects public API[/bold yellow]")

        self.console.print("=" * 50)

    def _get_confidence_color(self, confidence: float) -> str:
        """Get color for confidence score."""
        if confidence >= 0.95:
            return "green"
        elif confidence >= 0.80:
            return "cyan"
        elif confidence >= 0.60:
            return "yellow"
        else:
            return "red"

    def _show_dependency_tree(self, impact):
        """Display visual dependency impact tree."""

        self.console.print(f"\n[bold]üå≥ Dependency Impact Tree:[/bold]")
        self.console.print(f"[dim]Propagation depth: {impact.propagation_depth} layer(s)[/dim]\n")

        # Group by impact type
        direct_deps = {k: v for k, v in impact.dependency_tree.items() if v.impact_type == "direct"}
        indirect_deps = {k: v for k, v in impact.dependency_tree.items() if v.impact_type == "indirect"}
        test_deps = {k: v for k, v in impact.dependency_tree.items() if v.impact_type == "test"}

        # Show direct dependencies
        if direct_deps:
            self.console.print(f"[bold cyan]Direct Impact:[/bold cyan]")
            for file_path, dep_impact in list(direct_deps.items())[:8]:  # Limit display
                self._show_dependency_node(file_path, dep_impact, prefix="  ")

        # Show test dependencies
        if test_deps:
            self.console.print(f"\n[bold yellow]Test Files:[/bold yellow]")
            for file_path, dep_impact in list(test_deps.items())[:5]:
                self._show_dependency_node(file_path, dep_impact, prefix="  ")

        # Show indirect dependencies
        if indirect_deps:
            self.console.print(f"\n[bold magenta]Indirect Impact:[/bold magenta]")
            for file_path, dep_impact in list(indirect_deps.items())[:5]:
                self._show_dependency_node(file_path, dep_impact, prefix="  ", show_details=False)

        # Summary
        total_deps = len(impact.dependency_tree)
        if total_deps > 18:  # If we didn't show all
            self.console.print(f"\n[dim]... and {total_deps - 18} more files affected[/dim]")

    def _show_dependency_node(self, file_path: str, dep_impact, prefix: str = "", show_details: bool = True):
        """Display a single dependency node."""
        # Risk emoji and color
        risk_emoji = {
            "high": "üî¥",
            "medium": "üü°",
            "low": "üü¢"
        }
        risk_color = {
            "high": "red",
            "medium": "yellow",
            "low": "green"
        }

        emoji = risk_emoji.get(dep_impact.break_risk, "‚óã")
        color = risk_color.get(dep_impact.break_risk, "white")

        # File path with risk indicator
        self.console.print(f"{prefix}‚îú‚îÄ {emoji} [{color}]{file_path}[/{color}]")

        if show_details:
            # Show what functions/classes are used
            if dep_impact.functions_used:
                funcs = ", ".join(dep_impact.functions_used[:3])
                if len(dep_impact.functions_used) > 3:
                    funcs += f" +{len(dep_impact.functions_used) - 3}"
                self.console.print(f"{prefix}‚îÇ  [dim]‚Üí uses functions: {funcs}[/dim]")

            if dep_impact.classes_used:
                classes = ", ".join(dep_impact.classes_used[:3])
                if len(dep_impact.classes_used) > 3:
                    classes += f" +{len(dep_impact.classes_used) - 3}"
                self.console.print(f"{prefix}‚îÇ  [dim]‚Üí uses classes: {classes}[/dim]")

            # Show break risk if not low
            if dep_impact.break_risk != "low":
                self.console.print(f"{prefix}‚îÇ  [{color}]‚ö† {dep_impact.break_risk} risk of breaking[/{color}]")

    async def show_architecture(self):
        """Show detected architecture patterns."""
        # Build graph if not built
        if not self.codebase_graph:
            await self.build_codebase_graph()

        if not self.codebase_graph:
            self.console.print("[red]Could not build codebase graph[/red]")
            return

        patterns = self.codebase_graph.detect_architecture_patterns()

        self.console.print("\n[bold]Project Architecture:[/bold]\n")
        self.console.print(f"  Framework: [cyan]{patterns.get('framework', 'Unknown')}[/cyan]")
        self.console.print(f"  Structure: [cyan]{patterns.get('structure', 'Unknown')}[/cyan]")
        self.console.print(f"  Testing: [cyan]{patterns.get('testing', 'None detected')}[/cyan]")
        self.console.print(f"  Has tests: [{'green' if patterns.get('has_tests') else 'red'}]{patterns.get('has_tests')}[/]")
        self.console.print(f"  Has docs: [{'green' if patterns.get('has_docs') else 'red'}]{patterns.get('has_docs')}[/]")

        # Show file/entity statistics
        self.console.print(f"\n[bold]Statistics:[/bold]")
        self.console.print(f"  Total files: [cyan]{len(self.codebase_graph.files)}[/cyan]")
        self.console.print(f"  Total entities: [cyan]{len(self.codebase_graph.entities)}[/cyan]")

        # Show most connected files
        most_connected = sorted(
            self.codebase_graph.files.items(),
            key=lambda x: len(x[1].dependencies) + len(x[1].dependents),
            reverse=True
        )[:5]

        if most_connected:
            self.console.print(f"\n[bold]Most Connected Files:[/bold]")
            for file_path, file_node in most_connected:
                connections = len(file_node.dependencies) + len(file_node.dependents)
                self.console.print(f"  [cyan]{file_path}[/cyan] [dim]({connections} connections)[/dim]")

        self.console.print()

    async def analyze_file_structure(self, file_path: str):
        """Analyze file structure for large files before editing.

        Uses LargeFileHandler to provide intelligent guidance on how to
        read and edit large files efficiently.
        """
        from flux.core.large_file_handler import get_handler
        from pathlib import Path

        # Resolve file path
        full_path = self.cwd / file_path if not Path(file_path).is_absolute() else Path(file_path)

        if not full_path.exists():
            self.console.print(f"[red]File not found: {file_path}[/red]")
            return

        try:
            # Get handler and analyze
            handler = get_handler()
            analysis = handler.analyze_file(full_path)
            guide = handler.get_reading_guide(full_path)

            # Display analysis
            self.console.print(f"\n[bold]üìä File Structure Analysis[/bold]")
            self.console.print("=" * 70)
            self.console.print()

            # Show the guide (it's already formatted nicely)
            self.console.print(guide)

            self.console.print("\n" + "=" * 70)
            self.console.print("[dim]üí° Tip: Use the commands above to read specific sections efficiently[/dim]")
            self.console.print()

        except Exception as e:
            self.console.print(f"[red]Error analyzing file: {e}[/red]")

    async def show_suggestions(self):
        """Show proactive AI suggestions."""
        # Build graph and initialize suggestions engine if needed
        if not self.suggestions_engine:
            await self.build_codebase_graph()

        if not self.suggestions_engine:
            self.console.print("[red]Suggestions engine not available[/red]")
            return

        # Get suggestions
        suggestions = self.suggestions_engine.get_suggestions(max_suggestions=10, min_priority=Priority.LOW)

        if not suggestions:
            self.console.print("\n[dim]No structural suggestions detected.[/dim]")
            self.console.print("[dim]For deeper feature analysis, ask: 'Review this codebase and suggest specific improvements'[/dim]\n")
            return

        # Display suggestions
        self.console.print("\n[bold]üí° Proactive Suggestions:[/bold]")
        self.console.print("=" * 60)

        # Group by priority
        by_priority = {}
        for s in suggestions:
            if s.priority not in by_priority:
                by_priority[s.priority] = []
            by_priority[s.priority].append(s)

        priority_order = [Priority.CRITICAL, Priority.HIGH, Priority.MEDIUM, Priority.LOW]

        for priority in priority_order:
            if priority not in by_priority:
                continue

            priority_suggestions = by_priority[priority]

            # Priority header
            priority_emoji = {
                Priority.CRITICAL: "üî¥",
                Priority.HIGH: "üü†",
                Priority.MEDIUM: "üü°",
                Priority.LOW: "üü¢"
            }
            priority_color = {
                Priority.CRITICAL: "red",
                Priority.HIGH: "yellow",
                Priority.MEDIUM: "cyan",
                Priority.LOW: "green"
            }

            emoji = priority_emoji.get(priority, "‚óã")
            color = priority_color.get(priority, "white")

            self.console.print(f"\n[{color}]{emoji} {priority.value.upper()}[/{color}]")

            # Show suggestions
            for i, suggestion in enumerate(priority_suggestions, 1):
                self._show_suggestion(suggestion, index=i)

        self.console.print("\n" + "=" * 60)
        self.console.print("[dim]Tip: Ask Flux to implement any of these suggestions![/dim]\n")

    def _show_suggestion(self, suggestion, index: int):
        """Display a single suggestion."""
        # Type icon
        type_icons = {
            "next_action": "‚ñ∂Ô∏è",
            "code_quality": "‚ú®",
            "security": "üîí",
            "performance": "‚ö°",
            "testing": "üß™",
            "documentation": "üìù",
            "refactoring": "‚ôªÔ∏è"
        }
        icon = type_icons.get(suggestion.type.value, "‚Ä¢")

        # Title
        self.console.print(f"\n  {index}. {icon} [bold]{suggestion.title}[/bold]")

        # Description
        self.console.print(f"     [dim]{suggestion.description}[/dim]")

        # File and line
        if suggestion.file_path:
            location = f"{suggestion.file_path}"
            if suggestion.line_number:
                location += f":{suggestion.line_number}"
            self.console.print(f"     üìç {location}")

        # Action (what Flux can do)
        if suggestion.action:
            self.console.print(f"     üí° [cyan]{suggestion.action}[/cyan]")

        # Confidence
        confidence_color = self._get_confidence_color(suggestion.confidence)
        self.console.print(f"     Confidence: [{confidence_color}]{suggestion.confidence * 100:.0f}%[/{confidence_color}]")

        # Reasoning
        if suggestion.reasoning:
            self.console.print(f"     [dim italic]Why: {suggestion.reasoning}[/dim italic]")

    # Workspace Intelligence Commands

    async def handle_session_command(self, args: str):
        """Handle session sub-commands."""
        parts = args.split(maxsplit=1)
        if not parts:
            self.console.print("[red]Usage: /session save <name> | /session restore <id>[/red]")
            return

        command = parts[0].lower()

        if command == "save":
            name = parts[1] if len(parts) > 1 else "Work Session"
            session = self.workspace.save_session(name)
            self.console.print(f"[green]‚úì Session saved:[/green] {session.name}")
            self.console.print(f"   ID: [cyan]{session.id}[/cyan]")
            self.console.print(f"   Files: {len(session.files_modified)}")
            self.console.print(f"   Time: {session.time_spent_seconds / 60:.1f} minutes")

        elif command == "restore":
            if len(parts) < 2:
                self.console.print("[red]Please provide session ID[/red]")
                return

            session_id = parts[1]
            session = self.workspace.restore_session(session_id)

            if session:
                self.console.print(f"[green]‚úì Restored session:[/green] {session.name}")
                self.console.print(f"   Files: {len(session.open_files)}")
                if session.current_task_id:
                    task = self.workspace.get_task(session.current_task_id)
                    if task:
                        self.console.print(f"   Task: [yellow]{task.title}[/yellow]")
            else:
                self.console.print(f"[red]‚úó Session not found: {session_id}[/red]")

        elif command == "end":
            summary = self.workspace.end_session()
            if summary:
                self.console.print(f"[green]‚úì Session ended:[/green] {summary.session_name}")
                self.console.print(f"\n{summary.summary_text}")

                if summary.key_achievements:
                    self.console.print(f"\n[bold]Key Achievements:[/bold]")
                    for achievement in summary.key_achievements:
                        self.console.print(f"  {achievement}")
            else:
                self.console.print("[yellow]No active session[/yellow]")

        else:
            self.console.print(f"[red]Unknown session command: {command}[/red]")

    async def list_sessions(self):
        """List all sessions."""
        sessions = self.workspace.list_sessions(limit=10)

        if not sessions:
            self.console.print("\n[yellow]No sessions found[/yellow]\n")
            return

        self.console.print("\n[bold]üìã Work Sessions:[/bold]")
        self.console.print("=" * 60)

        for i, session in enumerate(sessions, 1):
            # Time info
            from datetime import datetime
            updated = datetime.fromtimestamp(session.updated_at).strftime("%Y-%m-%d %H:%M")
            duration = session.time_spent_seconds / 60

            # Status indicator
            is_active = self.workspace.active_session and self.workspace.active_session.id == session.id
            status = "‚ñ∂Ô∏è [green]ACTIVE[/green]" if is_active else "  "

            self.console.print(f"\n{status} {i}. [bold]{session.name}[/bold]")
            self.console.print(f"     ID: [dim]{session.id}[/dim]")
            self.console.print(f"     Updated: {updated}")
            self.console.print(f"     Duration: {duration:.1f} minutes")
            self.console.print(f"     Files: {len(session.files_modified)}")

            if session.description:
                self.console.print(f"     [dim]{session.description}[/dim]")

        self.console.print("\n" + "=" * 60)
        self.console.print("[dim]Use /session restore <id> to restore a session[/dim]\n")

    async def create_task(self, title: str):
        """Create a new task."""
        if not title:
            self.console.print("[red]Please provide a task title[/red]")
            return

        task = self.workspace.create_task(title)
        self.console.print(f"[green]‚úì Task created:[/green] {task.title}")
        self.console.print(f"   ID: [cyan]{task.id}[/cyan]")
        self.console.print(f"   Priority: {task.priority.value}")
        self.console.print(f"   Status: {task.status.value}")

    async def list_tasks(self):
        """List all tasks."""
        tasks = self.workspace.list_tasks(limit=20)
        next_task = self.workspace.suggest_next_task()
        self.display.print_tasks(tasks, next_task)

    async def show_work_summary(self):
        """Show work summary for today."""
        summary = self.workspace.get_daily_summary()

        # Prepare active session info
        active_session_info = None
        if self.workspace.active_session:
            session = self.workspace.active_session
            active_session_info = {
                'name': session.name,
                'duration_minutes': session.time_spent_seconds / 60,
                'files_count': len(session.files_modified)
            }
            if session.current_task_id:
                task = self.workspace.get_task(session.current_task_id)
                if task:
                    active_session_info['current_task'] = task.title

        self.display.print_work_summary(
            total_minutes=summary['total_minutes'],
            sessions=summary['sessions'],
            files_modified=summary['files_modified'],
            tasks_completed=summary['tasks_completed'],
            completed_task_titles=summary['completed_task_titles'],
            active_session_info=active_session_info
        )

    async def inspect_state(self):
        """Inspect current conversation and context state."""
        self.console.print("\n[bold]üîç Conversation State Inspector[/bold]")
        self.console.print("=" * 70)

        # Conversation history stats
        history = self.llm.conversation_history
        self.console.print(f"\n[bold cyan]Conversation History:[/bold cyan]")
        self.console.print(f"  Total messages: [cyan]{len(history)}[/cyan]")

        # Count by role
        user_msgs = sum(1 for m in history if m.get('role') == 'user')
        assistant_msgs = sum(1 for m in history if m.get('role') == 'assistant')
        tool_msgs = sum(1 for m in history if m.get('role') == 'tool')

        self.console.print(f"  User messages: [green]{user_msgs}[/green]")
        self.console.print(f"  Assistant messages: [yellow]{assistant_msgs}[/yellow]")
        self.console.print(f"  Tool messages: [blue]{tool_msgs}[/blue]")

        # Estimate token usage
        total_chars = sum(len(str(m.get('content', ''))) for m in history)
        est_tokens = total_chars // 4
        self.console.print(f"  Estimated tokens: [cyan]~{est_tokens:,}[/cyan]")

        # Recent messages
        self.console.print(f"\n[bold cyan]Last 5 Messages:[/bold cyan]")
        for i, msg in enumerate(history[-5:], 1):
            role = msg.get('role', 'unknown')
            content = str(msg.get('content', ''))[:100]
            has_tools = 'tool_calls' in msg

            role_color = {'user': 'green', 'assistant': 'yellow', 'tool': 'blue'}.get(role, 'white')
            self.console.print(f"  {i}. [{role_color}]{role}[/{role_color}]: {content}{'...' if len(str(msg.get('content', ''))) > 100 else ''}")
            if has_tools:
                self.console.print(f"     [dim](includes tool calls)[/dim]")

        # Current context
        self.console.print(f"\n[bold cyan]Current Context:[/bold cyan]")
        if self.memory.state.current_task:
            self.console.print(f"  Task: [yellow]{self.memory.state.current_task}[/yellow]")
        else:
            self.console.print(f"  Task: [dim]None[/dim]")

        # Modified files
        modified = self.workflow.get_modified_files()
        self.console.print(f"  Modified files: [cyan]{len(modified)}[/cyan]")
        if modified:
            for f in modified[:5]:
                self.console.print(f"    - {f}")
            if len(modified) > 5:
                self.console.print(f"    ... and {len(modified) - 5} more")

        # Failure tracker state
        if self.failure_tracker.failures:
            self.console.print(f"\n[bold yellow]‚ö†Ô∏è  Active Failures:[/bold yellow]")
            for tool_name, count in self.failure_tracker.failure_count_by_tool.items():
                self.console.print(f"  - {tool_name}: {count} failures")

        # Token usage from LLM
        usage = self.llm.get_token_usage()
        self.console.print(f"\n[bold cyan]Token Usage:[/bold cyan]")
        self.console.print(f"  Input: [cyan]{usage['input_tokens']:,}[/cyan]")
        self.console.print(f"  Output: [cyan]{usage['output_tokens']:,}[/cyan]")
        self.console.print(f"  Total: [cyan]{usage['total_tokens']:,}[/cyan]")
        self.console.print(f"  Cost: [green]${usage['estimated_cost']:.4f}[/green]")

        max_history = getattr(self.config, 'max_history', 8000)
        usage_percent = (usage['total_tokens'] / max_history) * 100 if max_history > 0 else 0

        if usage_percent > 80:
            self.console.print(f"  [yellow]‚ö†Ô∏è  At {usage_percent:.0f}% of limit[/yellow]")

        self.console.print("\n" + "=" * 70 + "\n")

    async def show_project_stats(self):
        """Show project-level statistics."""
        if not self.codebase_graph:
            await self.build_codebase_graph()

        if not self.codebase_graph:
            self.console.print("[red]Could not build codebase graph[/red]")
            return

        total_files = len(self.codebase_graph.files)
        total_entities = len(self.codebase_graph.entities)

        self.console.print("\n[bold]üìä Project Statistics:[/bold]")
        self.console.print("=" * 60)

        self.console.print(f"\nüìÇ Total Files: [cyan]{total_files}[/cyan]")
        self.console.print(f"üìö Total Entities: [cyan]{total_entities}[/cyan]")

        if self.project_info:
            self.console.print(f"\nüìà Project: [green]{self.project_info.name}[/green] ({self.project_info.project_type})")
            if self.project_info.frameworks:
                self.console.print(f"üíª Tech: [dim]{', '.join(self.project_info.frameworks)}[/dim]")

        self.console.print("\n" + "=" * 60 + "\n")

    async def run_autofix(self):
        """Run auto-fix on all project files."""
        if not self.auto_fixer.enabled:
            self.console.print("[yellow]Auto-fix is disabled. Enable with /autofix-on[/yellow]")
            return

        self.console.print("\n[bold cyan]üîß Running Auto-Fix...[/bold cyan]\n")

        # Find all supported files
        supported_extensions = {'.py', '.js', '.jsx', '.ts', '.tsx', '.json', '.yaml', '.yml'}
        files_to_check = []

        for ext in supported_extensions:
            files_to_check.extend(self.cwd.rglob(f'*{ext}'))

        # Filter out node_modules, venv, etc.
        ignore_dirs = {'node_modules', 'venv', '.venv', '__pycache__', '.git', 'dist', 'build'}
        files_to_check = [
            f for f in files_to_check
            if not any(part in f.parts for part in ignore_dirs)
        ]

        if not files_to_check:
            self.console.print("[yellow]No files found to auto-fix[/yellow]")
            return

        self.console.print(f"Found {len(files_to_check)} files to analyze...")

        total_fixes = 0
        files_fixed = 0

        # Process files
        import asyncio
        for i, file_path in enumerate(files_to_check, 1):
            if i % 10 == 0:
                self.console.print(f"[dim]Analyzing... {i}/{len(files_to_check)}[/dim]")

            # Analyze and apply fixes
            fixes = await asyncio.to_thread(self.auto_fixer.analyze_file, file_path)
            if fixes:
                success, count = await asyncio.to_thread(self.auto_fixer.apply_fixes, file_path, fixes)
                if success and count > 0:
                    total_fixes += count
                    files_fixed += 1
                    rel_path = file_path.relative_to(self.cwd)
                    self.console.print(f"  ‚úì [green]{rel_path}[/green] - {count} fix(es)")

        # Show summary
        self.console.print("\n[bold]Summary:[/bold]")
        self.console.print(f"  Files analyzed: [cyan]{len(files_to_check)}[/cyan]")
        self.console.print(f"  Files fixed: [green]{files_fixed}[/green]")
        self.console.print(f"  Total fixes: [green]{total_fixes}[/green]")

        if total_fixes > 0:
            self.console.print("\n[dim]Use /autofix-undo to undo last fix[/dim]")
            self.console.print("[dim]Use /autofix-summary to see detailed statistics[/dim]")

    async def start_autofix_watch(self, silent: bool = False):
        """Start auto-fix watch mode.

        Args:
            silent: If True, suppress startup messages (for auto-init)
        """
        if self.auto_fix_watcher and self.auto_fix_watcher.is_running:
            if not silent:
                self.console.print("[yellow]Auto-fix watch already running[/yellow]")
            return

        if not self.auto_fixer.enabled:
            if not silent:
                self.console.print("[yellow]Auto-fix is disabled. Enable with /autofix-on first.[/yellow]")
            return

        if not silent:
            self.console.print("\n[bold cyan]üëÅÔ∏è Starting Auto-Fix Watch Mode...[/bold cyan]")
            self.console.print(f"Watching: [cyan]{self.cwd}[/cyan]")
            self.console.print("[dim]Files will be auto-fixed when you save them[/dim]")
            self.console.print("[dim]Use /autofix-watch-stop to stop[/dim]\n")

        # Create watcher with callback
        def on_fix_applied(event: AutoFixEvent):
            """Show subtle notification when fix is applied."""
            rel_path = event.file_path.relative_to(self.cwd) if event.file_path.is_relative_to(self.cwd) else event.file_path
            fix_desc = ", ".join(event.fix_types)
            # Subtle single-line notification
            self.console.print(f"[dim]‚ú® Auto-fixed {rel_path} ({event.fixes_applied} fix: {fix_desc})[/dim]")

        self.auto_fix_watcher = AutoFixWatcher(
            self.auto_fixer,
            on_fix_applied=on_fix_applied
        )

        await self.auto_fix_watcher.start()
        self.console.print("[green]‚úì Auto-fix watch started[/green]")

    def stop_autofix_watch(self):
        """Stop auto-fix watch mode."""
        if not self.auto_fix_watcher:
            self.console.print("[yellow]Auto-fix watch not running[/yellow]")
            return

        if not self.auto_fix_watcher.is_running:
            self.console.print("[yellow]Auto-fix watch not running[/yellow]")
            return

        # Show final stats
        stats = self.auto_fix_watcher.get_stats()

        self.auto_fix_watcher.stop()
        self.console.print("\n[green]‚úì Auto-fix watch stopped[/green]")

        if stats['total_fixes'] > 0:
            self.console.print(f"  Fixed [cyan]{stats['files_fixed']}[/cyan] files with [cyan]{stats['total_fixes']}[/cyan] total fixes")
