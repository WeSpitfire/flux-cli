Create a new validation utility for Flux

TASK:
Add a new file flux/core/validators.py with validation functions for common operations.

FILE TO CREATE: flux/core/validators.py

CONTENTS:
```python
"""Validation utilities for Flux operations."""

from pathlib import Path
from typing import Dict, Any, Optional, List
import re


class ValidationError(Exception):
    """Raised when validation fails."""
    pass


class FilePathValidator:
    """Validates file paths and operations."""
    
    @staticmethod
    def validate_path(path: str, must_exist: bool = False) -> Dict[str, Any]:
        """Validate a file path.
        
        Args:
            path: Path to validate
            must_exist: Whether file must exist
            
        Returns:
            Dict with 'valid' bool and optional 'error' message
        """
        if not path:
            return {"valid": False, "error": "Path cannot be empty"}
        
        p = Path(path)
        
        # Check for invalid characters
        invalid_chars = ['<', '>', ':', '"', '|', '?', '*']
        if any(char in str(p) for char in invalid_chars):
            return {"valid": False, "error": f"Path contains invalid characters"}
        
        # Check if must exist
        if must_exist and not p.exists():
            return {"valid": False, "error": f"Path does not exist: {path}"}
        
        return {"valid": True}
    
    @staticmethod
    def validate_extension(path: str, allowed_extensions: List[str]) -> Dict[str, Any]:
        """Validate file extension.
        
        Args:
            path: File path
            allowed_extensions: List of allowed extensions (e.g., ['.py', '.js'])
            
        Returns:
            Dict with 'valid' bool and optional 'error'
        """
        p = Path(path)
        ext = p.suffix.lower()
        
        if ext not in allowed_extensions:
            return {
                "valid": False,
                "error": f"Extension {ext} not in allowed list: {allowed_extensions}"
            }
        
        return {"valid": True}


class CodeValidator:
    """Validates code patterns and conventions."""
    
    @staticmethod
    def validate_function_name(name: str) -> Dict[str, Any]:
        """Validate Python function name.
        
        Args:
            name: Function name to validate
            
        Returns:
            Dict with 'valid' bool and optional 'error'
        """
        if not name:
            return {"valid": False, "error": "Function name cannot be empty"}
        
        # Python naming convention: lowercase with underscores
        if not re.match(r'^[a-z_][a-z0-9_]*$', name):
            return {
                "valid": False,
                "error": f"Invalid function name '{name}'. Use lowercase with underscores."
            }
        
        # Check for reserved keywords
        reserved = ['def', 'class', 'if', 'else', 'return', 'import', 'from']
        if name in reserved:
            return {"valid": False, "error": f"'{name}' is a reserved keyword"}
        
        return {"valid": True}
    
    @staticmethod
    def validate_import_statement(statement: str) -> Dict[str, Any]:
        """Validate Python import statement.
        
        Args:
            statement: Import statement to validate
            
        Returns:
            Dict with 'valid' bool and optional 'error'
        """
        statement = statement.strip()
        
        if not statement:
            return {"valid": False, "error": "Import statement cannot be empty"}
        
        # Must start with 'import' or 'from'
        if not (statement.startswith('import ') or statement.startswith('from ')):
            return {
                "valid": False,
                "error": "Import must start with 'import' or 'from'"
            }
        
        return {"valid": True}


class OperationValidator:
    """Validates tool operations."""
    
    VALID_AST_OPERATIONS = [
        'add_function',
        'remove_function', 
        'modify_function',
        'add_import',
        'remove_import'
    ]
    
    @staticmethod
    def validate_ast_operation(operation: str) -> Dict[str, Any]:
        """Validate AST edit operation.
        
        Args:
            operation: Operation name
            
        Returns:
            Dict with 'valid' bool and optional 'error'
        """
        if operation not in OperationValidator.VALID_AST_OPERATIONS:
            return {
                "valid": False,
                "error": f"Invalid operation '{operation}'",
                "valid_operations": OperationValidator.VALID_AST_OPERATIONS
            }
        
        return {"valid": True}


def validate_file_operation(
    operation: str,
    path: str,
    content: Optional[str] = None
) -> Dict[str, Any]:
    """Validate a file operation before execution.
    
    Args:
        operation: Operation type ('read', 'write', 'edit')
        path: File path
        content: Content (for write/edit operations)
        
    Returns:
        Dict with 'valid' bool and optional 'errors' list
    """
    errors = []
    
    # Validate path
    path_result = FilePathValidator.validate_path(path)
    if not path_result["valid"]:
        errors.append(path_result["error"])
    
    # Validate write operations have content
    if operation in ['write', 'edit'] and not content:
        errors.append(f"{operation} operation requires content")
    
    # Validate read operations - file must exist
    if operation == 'read':
        exists_result = FilePathValidator.validate_path(path, must_exist=True)
        if not exists_result["valid"]:
            errors.append(exists_result["error"])
    
    if errors:
        return {"valid": False, "errors": errors}
    
    return {"valid": True}
```

INSTRUCTIONS:
1. Create the new file flux/core/validators.py with the code above
2. Add proper imports at the top
3. Make sure indentation is correct
4. File should be ~200 lines total

This will test:
- File creation (write_file tool)
- Large content handling
- Syntax validation (auto-rollback)
- Approval system (if not using --yes)